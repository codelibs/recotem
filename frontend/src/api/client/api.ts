/* tslint:disable */
/* eslint-disable */
/**
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface EvaluationConfig
 */
export interface EvaluationConfig {
    /**
     *
     * @type {number}
     * @memberof EvaluationConfig
     */
    id: number;
    /**
     *
     * @type {string}
     * @memberof EvaluationConfig
     */
    name?: string | null;
    /**
     *
     * @type {number}
     * @memberof EvaluationConfig
     */
    cutoff?: number;
    /**
     *
     * @type {TargetMetricEnum}
     * @memberof EvaluationConfig
     */
    target_metric?: TargetMetricEnum;
}
/**
 *
 * @export
 * @interface ModelConfiguration
 */
export interface ModelConfiguration {
    /**
     *
     * @type {number}
     * @memberof ModelConfiguration
     */
    id: number;
    /**
     *
     * @type {string}
     * @memberof ModelConfiguration
     */
    name?: string | null;
    /**
     *
     * @type {string}
     * @memberof ModelConfiguration
     */
    recommender_class_name: string;
    /**
     *
     * @type {string}
     * @memberof ModelConfiguration
     */
    parameters_json: string;
    /**
     *
     * @type {string}
     * @memberof ModelConfiguration
     */
    ins_datetime: string;
    /**
     *
     * @type {string}
     * @memberof ModelConfiguration
     */
    upd_datetime: string;
    /**
     *
     * @type {number}
     * @memberof ModelConfiguration
     */
    project: number;
}
/**
 *
 * @export
 * @interface ParameterTuningJob
 */
export interface ParameterTuningJob {
    /**
     *
     * @type {number}
     * @memberof ParameterTuningJob
     */
    id: number;
    /**
     *
     * @type {string}
     * @memberof ParameterTuningJob
     */
    name?: string | null;
    /**
     *
     * @type {number}
     * @memberof ParameterTuningJob
     */
    n_tasks_parallel?: number;
    /**
     *
     * @type {number}
     * @memberof ParameterTuningJob
     */
    n_trials?: number;
    /**
     *
     * @type {number}
     * @memberof ParameterTuningJob
     */
    memory_budget?: number;
    /**
     *
     * @type {number}
     * @memberof ParameterTuningJob
     */
    timeout_overall?: number | null;
    /**
     *
     * @type {number}
     * @memberof ParameterTuningJob
     */
    timeout_singlestep?: number | null;
    /**
     *
     * @type {number}
     * @memberof ParameterTuningJob
     */
    random_seed?: number | null;
    /**
     *
     * @type {string}
     * @memberof ParameterTuningJob
     */
    ins_datetime: string;
    /**
     *
     * @type {string}
     * @memberof ParameterTuningJob
     */
    upd_datetime: string;
    /**
     *
     * @type {number}
     * @memberof ParameterTuningJob
     */
    data: number;
    /**
     *
     * @type {number}
     * @memberof ParameterTuningJob
     */
    split?: number | null;
    /**
     *
     * @type {number}
     * @memberof ParameterTuningJob
     */
    evaluation: number;
    /**
     *
     * @type {number}
     * @memberof ParameterTuningJob
     */
    best_config?: number | null;
    /**
     *
     * @type {number}
     * @memberof ParameterTuningJob
     */
    tuned_model?: number | null;
}
/**
 *
 * @export
 * @interface PatchedEvaluationConfig
 */
export interface PatchedEvaluationConfig {
    /**
     *
     * @type {number}
     * @memberof PatchedEvaluationConfig
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof PatchedEvaluationConfig
     */
    name?: string | null;
    /**
     *
     * @type {number}
     * @memberof PatchedEvaluationConfig
     */
    cutoff?: number;
    /**
     *
     * @type {TargetMetricEnum}
     * @memberof PatchedEvaluationConfig
     */
    target_metric?: TargetMetricEnum;
}
/**
 *
 * @export
 * @interface PatchedModelConfiguration
 */
export interface PatchedModelConfiguration {
    /**
     *
     * @type {number}
     * @memberof PatchedModelConfiguration
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof PatchedModelConfiguration
     */
    name?: string | null;
    /**
     *
     * @type {string}
     * @memberof PatchedModelConfiguration
     */
    recommender_class_name?: string;
    /**
     *
     * @type {string}
     * @memberof PatchedModelConfiguration
     */
    parameters_json?: string;
    /**
     *
     * @type {string}
     * @memberof PatchedModelConfiguration
     */
    ins_datetime?: string;
    /**
     *
     * @type {string}
     * @memberof PatchedModelConfiguration
     */
    upd_datetime?: string;
    /**
     *
     * @type {number}
     * @memberof PatchedModelConfiguration
     */
    project?: number;
}
/**
 *
 * @export
 * @interface PatchedParameterTuningJob
 */
export interface PatchedParameterTuningJob {
    /**
     *
     * @type {number}
     * @memberof PatchedParameterTuningJob
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof PatchedParameterTuningJob
     */
    name?: string | null;
    /**
     *
     * @type {number}
     * @memberof PatchedParameterTuningJob
     */
    n_tasks_parallel?: number;
    /**
     *
     * @type {number}
     * @memberof PatchedParameterTuningJob
     */
    n_trials?: number;
    /**
     *
     * @type {number}
     * @memberof PatchedParameterTuningJob
     */
    memory_budget?: number;
    /**
     *
     * @type {number}
     * @memberof PatchedParameterTuningJob
     */
    timeout_overall?: number | null;
    /**
     *
     * @type {number}
     * @memberof PatchedParameterTuningJob
     */
    timeout_singlestep?: number | null;
    /**
     *
     * @type {number}
     * @memberof PatchedParameterTuningJob
     */
    random_seed?: number | null;
    /**
     *
     * @type {string}
     * @memberof PatchedParameterTuningJob
     */
    ins_datetime?: string;
    /**
     *
     * @type {string}
     * @memberof PatchedParameterTuningJob
     */
    upd_datetime?: string;
    /**
     *
     * @type {number}
     * @memberof PatchedParameterTuningJob
     */
    data?: number;
    /**
     *
     * @type {number}
     * @memberof PatchedParameterTuningJob
     */
    split?: number | null;
    /**
     *
     * @type {number}
     * @memberof PatchedParameterTuningJob
     */
    evaluation?: number;
    /**
     *
     * @type {number}
     * @memberof PatchedParameterTuningJob
     */
    best_config?: number | null;
    /**
     *
     * @type {number}
     * @memberof PatchedParameterTuningJob
     */
    tuned_model?: number | null;
}
/**
 *
 * @export
 * @interface PatchedProject
 */
export interface PatchedProject {
    /**
     *
     * @type {number}
     * @memberof PatchedProject
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof PatchedProject
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof PatchedProject
     */
    user_column?: string;
    /**
     *
     * @type {string}
     * @memberof PatchedProject
     */
    item_column?: string;
    /**
     *
     * @type {string}
     * @memberof PatchedProject
     */
    time_column?: string | null;
    /**
     *
     * @type {string}
     * @memberof PatchedProject
     */
    ins_datetime?: string;
    /**
     *
     * @type {string}
     * @memberof PatchedProject
     */
    upd_datetime?: string;
}
/**
 *
 * @export
 * @interface PatchedSplitConfig
 */
export interface PatchedSplitConfig {
    /**
     *
     * @type {number}
     * @memberof PatchedSplitConfig
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof PatchedSplitConfig
     */
    name?: string | null;
    /**
     *
     * @type {SchemeEnum}
     * @memberof PatchedSplitConfig
     */
    scheme?: SchemeEnum;
    /**
     *
     * @type {number}
     * @memberof PatchedSplitConfig
     */
    heldout_ratio?: number;
    /**
     *
     * @type {number}
     * @memberof PatchedSplitConfig
     */
    n_heldout?: number | null;
    /**
     *
     * @type {number}
     * @memberof PatchedSplitConfig
     */
    test_user_ratio?: number;
    /**
     *
     * @type {number}
     * @memberof PatchedSplitConfig
     */
    n_test_users?: number | null;
    /**
     *
     * @type {number}
     * @memberof PatchedSplitConfig
     */
    random_seed?: number;
}
/**
 *
 * @export
 * @interface PatchedTrainedModel
 */
export interface PatchedTrainedModel {
    /**
     *
     * @type {number}
     * @memberof PatchedTrainedModel
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof PatchedTrainedModel
     */
    name?: string | null;
    /**
     *
     * @type {string}
     * @memberof PatchedTrainedModel
     */
    model_path?: string | null;
    /**
     *
     * @type {string}
     * @memberof PatchedTrainedModel
     */
    ins_datetime?: string;
    /**
     *
     * @type {string}
     * @memberof PatchedTrainedModel
     */
    upd_datetime?: string;
    /**
     *
     * @type {number}
     * @memberof PatchedTrainedModel
     */
    configuration?: number;
    /**
     *
     * @type {number}
     * @memberof PatchedTrainedModel
     */
    data_loc?: number;
}
/**
 *
 * @export
 * @interface PatchedTrainingData
 */
export interface PatchedTrainingData {
    /**
     *
     * @type {number}
     * @memberof PatchedTrainingData
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof PatchedTrainingData
     */
    upload_path?: string;
    /**
     *
     * @type {string}
     * @memberof PatchedTrainingData
     */
    ins_datetime?: string;
    /**
     *
     * @type {string}
     * @memberof PatchedTrainingData
     */
    upd_datetime?: string;
    /**
     *
     * @type {number}
     * @memberof PatchedTrainingData
     */
    project?: number;
}
/**
 *
 * @export
 * @interface Project
 */
export interface Project {
    /**
     *
     * @type {number}
     * @memberof Project
     */
    id: number;
    /**
     *
     * @type {string}
     * @memberof Project
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof Project
     */
    user_column: string;
    /**
     *
     * @type {string}
     * @memberof Project
     */
    item_column: string;
    /**
     *
     * @type {string}
     * @memberof Project
     */
    time_column?: string | null;
    /**
     *
     * @type {string}
     * @memberof Project
     */
    ins_datetime: string;
    /**
     *
     * @type {string}
     * @memberof Project
     */
    upd_datetime: string;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum SchemeEnum {
    Rg = 'RG',
    Tg = 'TG',
    Tu = 'TU'
}

/**
 *
 * @export
 * @interface SplitConfig
 */
export interface SplitConfig {
    /**
     *
     * @type {number}
     * @memberof SplitConfig
     */
    id: number;
    /**
     *
     * @type {string}
     * @memberof SplitConfig
     */
    name?: string | null;
    /**
     *
     * @type {SchemeEnum}
     * @memberof SplitConfig
     */
    scheme?: SchemeEnum;
    /**
     *
     * @type {number}
     * @memberof SplitConfig
     */
    heldout_ratio?: number;
    /**
     *
     * @type {number}
     * @memberof SplitConfig
     */
    n_heldout?: number | null;
    /**
     *
     * @type {number}
     * @memberof SplitConfig
     */
    test_user_ratio?: number;
    /**
     *
     * @type {number}
     * @memberof SplitConfig
     */
    n_test_users?: number | null;
    /**
     *
     * @type {number}
     * @memberof SplitConfig
     */
    random_seed?: number;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum TargetMetricEnum {
    Ndcg = 'ndcg',
    Map = 'map',
    Recall = 'recall',
    Hit = 'hit'
}

/**
 *
 * @export
 * @interface TaskLog
 */
export interface TaskLog {
    /**
     *
     * @type {number}
     * @memberof TaskLog
     */
    id: number;
    /**
     *
     * @type {string}
     * @memberof TaskLog
     */
    contents?: string;
    /**
     *
     * @type {string}
     * @memberof TaskLog
     */
    ins_datetime: string;
    /**
     *
     * @type {number}
     * @memberof TaskLog
     */
    task: number;
}
/**
 *
 * @export
 * @interface TokenObtainPair
 */
export interface TokenObtainPair {
    /**
     *
     * @type {string}
     * @memberof TokenObtainPair
     */
    username: string;
    /**
     *
     * @type {string}
     * @memberof TokenObtainPair
     */
    password: string;
    /**
     *
     * @type {string}
     * @memberof TokenObtainPair
     */
    access: string;
    /**
     *
     * @type {string}
     * @memberof TokenObtainPair
     */
    refresh: string;
}
/**
 *
 * @export
 * @interface TokenRefresh
 */
export interface TokenRefresh {
    /**
     *
     * @type {string}
     * @memberof TokenRefresh
     */
    access: string;
    /**
     *
     * @type {string}
     * @memberof TokenRefresh
     */
    refresh: string;
}
/**
 *
 * @export
 * @interface TrainedModel
 */
export interface TrainedModel {
    /**
     *
     * @type {number}
     * @memberof TrainedModel
     */
    id: number;
    /**
     *
     * @type {string}
     * @memberof TrainedModel
     */
    name?: string | null;
    /**
     *
     * @type {string}
     * @memberof TrainedModel
     */
    model_path?: string | null;
    /**
     *
     * @type {string}
     * @memberof TrainedModel
     */
    ins_datetime: string;
    /**
     *
     * @type {string}
     * @memberof TrainedModel
     */
    upd_datetime: string;
    /**
     *
     * @type {number}
     * @memberof TrainedModel
     */
    configuration: number;
    /**
     *
     * @type {number}
     * @memberof TrainedModel
     */
    data_loc: number;
}
/**
 *
 * @export
 * @interface TrainingData
 */
export interface TrainingData {
    /**
     *
     * @type {number}
     * @memberof TrainingData
     */
    id: number;
    /**
     *
     * @type {string}
     * @memberof TrainingData
     */
    upload_path: string;
    /**
     *
     * @type {string}
     * @memberof TrainingData
     */
    ins_datetime: string;
    /**
     *
     * @type {string}
     * @memberof TrainingData
     */
    upd_datetime: string;
    /**
     *
     * @type {number}
     * @memberof TrainingData
     */
    project: number;
}

/**
 * EvaluationConfigApi - axios parameter creator
 * @export
 */
export const EvaluationConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {EvaluationConfig} [evaluationConfig]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationConfigCreate: async (evaluationConfig?: EvaluationConfig, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/evaluation_config/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(evaluationConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this evaluation config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationConfigDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('evaluationConfigDestroy', 'id', id)
            const localVarPath = `/api/evaluation_config/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} [id]
         * @param {string} [name]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationConfigList: async (id?: number, name?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/evaluation_config/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this evaluation config.
         * @param {PatchedEvaluationConfig} [patchedEvaluationConfig]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationConfigPartialUpdate: async (id: number, patchedEvaluationConfig?: PatchedEvaluationConfig, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('evaluationConfigPartialUpdate', 'id', id)
            const localVarPath = `/api/evaluation_config/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedEvaluationConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this evaluation config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationConfigRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('evaluationConfigRetrieve', 'id', id)
            const localVarPath = `/api/evaluation_config/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this evaluation config.
         * @param {EvaluationConfig} [evaluationConfig]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationConfigUpdate: async (id: number, evaluationConfig?: EvaluationConfig, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('evaluationConfigUpdate', 'id', id)
            const localVarPath = `/api/evaluation_config/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(evaluationConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EvaluationConfigApi - functional programming interface
 * @export
 */
export const EvaluationConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EvaluationConfigApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {EvaluationConfig} [evaluationConfig]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluationConfigCreate(evaluationConfig?: EvaluationConfig, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EvaluationConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluationConfigCreate(evaluationConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this evaluation config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluationConfigDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluationConfigDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} [id]
         * @param {string} [name]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluationConfigList(id?: number, name?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EvaluationConfig>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluationConfigList(id, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this evaluation config.
         * @param {PatchedEvaluationConfig} [patchedEvaluationConfig]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluationConfigPartialUpdate(id: number, patchedEvaluationConfig?: PatchedEvaluationConfig, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EvaluationConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluationConfigPartialUpdate(id, patchedEvaluationConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this evaluation config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluationConfigRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EvaluationConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluationConfigRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this evaluation config.
         * @param {EvaluationConfig} [evaluationConfig]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluationConfigUpdate(id: number, evaluationConfig?: EvaluationConfig, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EvaluationConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluationConfigUpdate(id, evaluationConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EvaluationConfigApi - factory interface
 * @export
 */
export const EvaluationConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EvaluationConfigApiFp(configuration)
    return {
        /**
         *
         * @param {EvaluationConfig} [evaluationConfig]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationConfigCreate(evaluationConfig?: EvaluationConfig, options?: any): AxiosPromise<EvaluationConfig> {
            return localVarFp.evaluationConfigCreate(evaluationConfig, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this evaluation config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationConfigDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.evaluationConfigDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} [id]
         * @param {string} [name]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationConfigList(id?: number, name?: string, options?: any): AxiosPromise<Array<EvaluationConfig>> {
            return localVarFp.evaluationConfigList(id, name, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this evaluation config.
         * @param {PatchedEvaluationConfig} [patchedEvaluationConfig]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationConfigPartialUpdate(id: number, patchedEvaluationConfig?: PatchedEvaluationConfig, options?: any): AxiosPromise<EvaluationConfig> {
            return localVarFp.evaluationConfigPartialUpdate(id, patchedEvaluationConfig, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this evaluation config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationConfigRetrieve(id: number, options?: any): AxiosPromise<EvaluationConfig> {
            return localVarFp.evaluationConfigRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this evaluation config.
         * @param {EvaluationConfig} [evaluationConfig]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationConfigUpdate(id: number, evaluationConfig?: EvaluationConfig, options?: any): AxiosPromise<EvaluationConfig> {
            return localVarFp.evaluationConfigUpdate(id, evaluationConfig, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EvaluationConfigApi - object-oriented interface
 * @export
 * @class EvaluationConfigApi
 * @extends {BaseAPI}
 */
export class EvaluationConfigApi extends BaseAPI {
    /**
     *
     * @param {EvaluationConfig} [evaluationConfig]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationConfigApi
     */
    public evaluationConfigCreate(evaluationConfig?: EvaluationConfig, options?: any) {
        return EvaluationConfigApiFp(this.configuration).evaluationConfigCreate(evaluationConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this evaluation config.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationConfigApi
     */
    public evaluationConfigDestroy(id: number, options?: any) {
        return EvaluationConfigApiFp(this.configuration).evaluationConfigDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} [id]
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationConfigApi
     */
    public evaluationConfigList(id?: number, name?: string, options?: any) {
        return EvaluationConfigApiFp(this.configuration).evaluationConfigList(id, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this evaluation config.
     * @param {PatchedEvaluationConfig} [patchedEvaluationConfig]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationConfigApi
     */
    public evaluationConfigPartialUpdate(id: number, patchedEvaluationConfig?: PatchedEvaluationConfig, options?: any) {
        return EvaluationConfigApiFp(this.configuration).evaluationConfigPartialUpdate(id, patchedEvaluationConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this evaluation config.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationConfigApi
     */
    public evaluationConfigRetrieve(id: number, options?: any) {
        return EvaluationConfigApiFp(this.configuration).evaluationConfigRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this evaluation config.
     * @param {EvaluationConfig} [evaluationConfig]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationConfigApi
     */
    public evaluationConfigUpdate(id: number, evaluationConfig?: EvaluationConfig, options?: any) {
        return EvaluationConfigApiFp(this.configuration).evaluationConfigUpdate(id, evaluationConfig, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ModelConfigurationApi - axios parameter creator
 * @export
 */
export const ModelConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {ModelConfiguration} modelConfiguration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelConfigurationCreate: async (modelConfiguration: ModelConfiguration, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelConfiguration' is not null or undefined
            assertParamExists('modelConfigurationCreate', 'modelConfiguration', modelConfiguration)
            const localVarPath = `/api/model_configuration/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modelConfiguration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this model configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelConfigurationDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('modelConfigurationDestroy', 'id', id)
            const localVarPath = `/api/model_configuration/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} [id]
         * @param {number} [project]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelConfigurationList: async (id?: number, project?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/model_configuration/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (project !== undefined) {
                localVarQueryParameter['project'] = project;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this model configuration.
         * @param {PatchedModelConfiguration} [patchedModelConfiguration]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelConfigurationPartialUpdate: async (id: number, patchedModelConfiguration?: PatchedModelConfiguration, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('modelConfigurationPartialUpdate', 'id', id)
            const localVarPath = `/api/model_configuration/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedModelConfiguration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this model configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelConfigurationRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('modelConfigurationRetrieve', 'id', id)
            const localVarPath = `/api/model_configuration/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this model configuration.
         * @param {ModelConfiguration} modelConfiguration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelConfigurationUpdate: async (id: number, modelConfiguration: ModelConfiguration, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('modelConfigurationUpdate', 'id', id)
            // verify required parameter 'modelConfiguration' is not null or undefined
            assertParamExists('modelConfigurationUpdate', 'modelConfiguration', modelConfiguration)
            const localVarPath = `/api/model_configuration/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modelConfiguration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModelConfigurationApi - functional programming interface
 * @export
 */
export const ModelConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModelConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {ModelConfiguration} modelConfiguration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modelConfigurationCreate(modelConfiguration: ModelConfiguration, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modelConfigurationCreate(modelConfiguration, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this model configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modelConfigurationDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modelConfigurationDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} [id]
         * @param {number} [project]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modelConfigurationList(id?: number, project?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelConfiguration>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modelConfigurationList(id, project, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this model configuration.
         * @param {PatchedModelConfiguration} [patchedModelConfiguration]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modelConfigurationPartialUpdate(id: number, patchedModelConfiguration?: PatchedModelConfiguration, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modelConfigurationPartialUpdate(id, patchedModelConfiguration, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this model configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modelConfigurationRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modelConfigurationRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this model configuration.
         * @param {ModelConfiguration} modelConfiguration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modelConfigurationUpdate(id: number, modelConfiguration: ModelConfiguration, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modelConfigurationUpdate(id, modelConfiguration, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ModelConfigurationApi - factory interface
 * @export
 */
export const ModelConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModelConfigurationApiFp(configuration)
    return {
        /**
         *
         * @param {ModelConfiguration} modelConfiguration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelConfigurationCreate(modelConfiguration: ModelConfiguration, options?: any): AxiosPromise<ModelConfiguration> {
            return localVarFp.modelConfigurationCreate(modelConfiguration, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this model configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelConfigurationDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.modelConfigurationDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} [id]
         * @param {number} [project]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelConfigurationList(id?: number, project?: number, options?: any): AxiosPromise<Array<ModelConfiguration>> {
            return localVarFp.modelConfigurationList(id, project, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this model configuration.
         * @param {PatchedModelConfiguration} [patchedModelConfiguration]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelConfigurationPartialUpdate(id: number, patchedModelConfiguration?: PatchedModelConfiguration, options?: any): AxiosPromise<ModelConfiguration> {
            return localVarFp.modelConfigurationPartialUpdate(id, patchedModelConfiguration, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this model configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelConfigurationRetrieve(id: number, options?: any): AxiosPromise<ModelConfiguration> {
            return localVarFp.modelConfigurationRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this model configuration.
         * @param {ModelConfiguration} modelConfiguration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelConfigurationUpdate(id: number, modelConfiguration: ModelConfiguration, options?: any): AxiosPromise<ModelConfiguration> {
            return localVarFp.modelConfigurationUpdate(id, modelConfiguration, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModelConfigurationApi - object-oriented interface
 * @export
 * @class ModelConfigurationApi
 * @extends {BaseAPI}
 */
export class ModelConfigurationApi extends BaseAPI {
    /**
     *
     * @param {ModelConfiguration} modelConfiguration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelConfigurationApi
     */
    public modelConfigurationCreate(modelConfiguration: ModelConfiguration, options?: any) {
        return ModelConfigurationApiFp(this.configuration).modelConfigurationCreate(modelConfiguration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this model configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelConfigurationApi
     */
    public modelConfigurationDestroy(id: number, options?: any) {
        return ModelConfigurationApiFp(this.configuration).modelConfigurationDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} [id]
     * @param {number} [project]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelConfigurationApi
     */
    public modelConfigurationList(id?: number, project?: number, options?: any) {
        return ModelConfigurationApiFp(this.configuration).modelConfigurationList(id, project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this model configuration.
     * @param {PatchedModelConfiguration} [patchedModelConfiguration]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelConfigurationApi
     */
    public modelConfigurationPartialUpdate(id: number, patchedModelConfiguration?: PatchedModelConfiguration, options?: any) {
        return ModelConfigurationApiFp(this.configuration).modelConfigurationPartialUpdate(id, patchedModelConfiguration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this model configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelConfigurationApi
     */
    public modelConfigurationRetrieve(id: number, options?: any) {
        return ModelConfigurationApiFp(this.configuration).modelConfigurationRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this model configuration.
     * @param {ModelConfiguration} modelConfiguration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelConfigurationApi
     */
    public modelConfigurationUpdate(id: number, modelConfiguration: ModelConfiguration, options?: any) {
        return ModelConfigurationApiFp(this.configuration).modelConfigurationUpdate(id, modelConfiguration, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ParameterTuningJobApi - axios parameter creator
 * @export
 */
export const ParameterTuningJobApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {ParameterTuningJob} parameterTuningJob
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parameterTuningJobCreate: async (parameterTuningJob: ParameterTuningJob, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'parameterTuningJob' is not null or undefined
            assertParamExists('parameterTuningJobCreate', 'parameterTuningJob', parameterTuningJob)
            const localVarPath = `/api/parameter_tuning_job/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(parameterTuningJob, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this parameter tuning job.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parameterTuningJobDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('parameterTuningJobDestroy', 'id', id)
            const localVarPath = `/api/parameter_tuning_job/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} [dataProject]
         * @param {number} [id]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parameterTuningJobList: async (dataProject?: number, id?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/parameter_tuning_job/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dataProject !== undefined) {
                localVarQueryParameter['data__project'] = dataProject;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this parameter tuning job.
         * @param {PatchedParameterTuningJob} [patchedParameterTuningJob]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parameterTuningJobPartialUpdate: async (id: number, patchedParameterTuningJob?: PatchedParameterTuningJob, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('parameterTuningJobPartialUpdate', 'id', id)
            const localVarPath = `/api/parameter_tuning_job/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedParameterTuningJob, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this parameter tuning job.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parameterTuningJobRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('parameterTuningJobRetrieve', 'id', id)
            const localVarPath = `/api/parameter_tuning_job/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this parameter tuning job.
         * @param {ParameterTuningJob} parameterTuningJob
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parameterTuningJobUpdate: async (id: number, parameterTuningJob: ParameterTuningJob, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('parameterTuningJobUpdate', 'id', id)
            // verify required parameter 'parameterTuningJob' is not null or undefined
            assertParamExists('parameterTuningJobUpdate', 'parameterTuningJob', parameterTuningJob)
            const localVarPath = `/api/parameter_tuning_job/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(parameterTuningJob, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ParameterTuningJobApi - functional programming interface
 * @export
 */
export const ParameterTuningJobApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ParameterTuningJobApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {ParameterTuningJob} parameterTuningJob
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parameterTuningJobCreate(parameterTuningJob: ParameterTuningJob, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParameterTuningJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parameterTuningJobCreate(parameterTuningJob, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this parameter tuning job.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parameterTuningJobDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parameterTuningJobDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} [dataProject]
         * @param {number} [id]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parameterTuningJobList(dataProject?: number, id?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ParameterTuningJob>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parameterTuningJobList(dataProject, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this parameter tuning job.
         * @param {PatchedParameterTuningJob} [patchedParameterTuningJob]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parameterTuningJobPartialUpdate(id: number, patchedParameterTuningJob?: PatchedParameterTuningJob, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParameterTuningJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parameterTuningJobPartialUpdate(id, patchedParameterTuningJob, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this parameter tuning job.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parameterTuningJobRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParameterTuningJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parameterTuningJobRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this parameter tuning job.
         * @param {ParameterTuningJob} parameterTuningJob
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parameterTuningJobUpdate(id: number, parameterTuningJob: ParameterTuningJob, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParameterTuningJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parameterTuningJobUpdate(id, parameterTuningJob, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ParameterTuningJobApi - factory interface
 * @export
 */
export const ParameterTuningJobApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ParameterTuningJobApiFp(configuration)
    return {
        /**
         *
         * @param {ParameterTuningJob} parameterTuningJob
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parameterTuningJobCreate(parameterTuningJob: ParameterTuningJob, options?: any): AxiosPromise<ParameterTuningJob> {
            return localVarFp.parameterTuningJobCreate(parameterTuningJob, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this parameter tuning job.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parameterTuningJobDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.parameterTuningJobDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} [dataProject]
         * @param {number} [id]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parameterTuningJobList(dataProject?: number, id?: number, options?: any): AxiosPromise<Array<ParameterTuningJob>> {
            return localVarFp.parameterTuningJobList(dataProject, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this parameter tuning job.
         * @param {PatchedParameterTuningJob} [patchedParameterTuningJob]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parameterTuningJobPartialUpdate(id: number, patchedParameterTuningJob?: PatchedParameterTuningJob, options?: any): AxiosPromise<ParameterTuningJob> {
            return localVarFp.parameterTuningJobPartialUpdate(id, patchedParameterTuningJob, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this parameter tuning job.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parameterTuningJobRetrieve(id: number, options?: any): AxiosPromise<ParameterTuningJob> {
            return localVarFp.parameterTuningJobRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this parameter tuning job.
         * @param {ParameterTuningJob} parameterTuningJob
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parameterTuningJobUpdate(id: number, parameterTuningJob: ParameterTuningJob, options?: any): AxiosPromise<ParameterTuningJob> {
            return localVarFp.parameterTuningJobUpdate(id, parameterTuningJob, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ParameterTuningJobApi - object-oriented interface
 * @export
 * @class ParameterTuningJobApi
 * @extends {BaseAPI}
 */
export class ParameterTuningJobApi extends BaseAPI {
    /**
     *
     * @param {ParameterTuningJob} parameterTuningJob
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParameterTuningJobApi
     */
    public parameterTuningJobCreate(parameterTuningJob: ParameterTuningJob, options?: any) {
        return ParameterTuningJobApiFp(this.configuration).parameterTuningJobCreate(parameterTuningJob, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this parameter tuning job.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParameterTuningJobApi
     */
    public parameterTuningJobDestroy(id: number, options?: any) {
        return ParameterTuningJobApiFp(this.configuration).parameterTuningJobDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} [dataProject]
     * @param {number} [id]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParameterTuningJobApi
     */
    public parameterTuningJobList(dataProject?: number, id?: number, options?: any) {
        return ParameterTuningJobApiFp(this.configuration).parameterTuningJobList(dataProject, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this parameter tuning job.
     * @param {PatchedParameterTuningJob} [patchedParameterTuningJob]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParameterTuningJobApi
     */
    public parameterTuningJobPartialUpdate(id: number, patchedParameterTuningJob?: PatchedParameterTuningJob, options?: any) {
        return ParameterTuningJobApiFp(this.configuration).parameterTuningJobPartialUpdate(id, patchedParameterTuningJob, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this parameter tuning job.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParameterTuningJobApi
     */
    public parameterTuningJobRetrieve(id: number, options?: any) {
        return ParameterTuningJobApiFp(this.configuration).parameterTuningJobRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this parameter tuning job.
     * @param {ParameterTuningJob} parameterTuningJob
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParameterTuningJobApi
     */
    public parameterTuningJobUpdate(id: number, parameterTuningJob: ParameterTuningJob, options?: any) {
        return ParameterTuningJobApiFp(this.configuration).parameterTuningJobUpdate(id, parameterTuningJob, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectApi - axios parameter creator
 * @export
 */
export const ProjectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {Project} project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectCreate: async (project: Project, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectCreate', 'project', project)
            const localVarPath = `/api/project/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(project, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectDestroy', 'id', id)
            const localVarPath = `/api/project/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} [id]
         * @param {string} [name]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectList: async (id?: number, name?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/project/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this project.
         * @param {PatchedProject} [patchedProject]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectPartialUpdate: async (id: number, patchedProject?: PatchedProject, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectPartialUpdate', 'id', id)
            const localVarPath = `/api/project/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedProject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectRetrieve', 'id', id)
            const localVarPath = `/api/project/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this project.
         * @param {Project} project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectUpdate: async (id: number, project: Project, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectUpdate', 'id', id)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectUpdate', 'project', project)
            const localVarPath = `/api/project/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(project, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectApi - functional programming interface
 * @export
 */
export const ProjectApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {Project} project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectCreate(project: Project, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectCreate(project, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} [id]
         * @param {string} [name]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectList(id?: number, name?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Project>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectList(id, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this project.
         * @param {PatchedProject} [patchedProject]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectPartialUpdate(id: number, patchedProject?: PatchedProject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectPartialUpdate(id, patchedProject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this project.
         * @param {Project} project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectUpdate(id: number, project: Project, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectUpdate(id, project, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectApi - factory interface
 * @export
 */
export const ProjectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectApiFp(configuration)
    return {
        /**
         *
         * @param {Project} project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectCreate(project: Project, options?: any): AxiosPromise<Project> {
            return localVarFp.projectCreate(project, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.projectDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} [id]
         * @param {string} [name]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectList(id?: number, name?: string, options?: any): AxiosPromise<Array<Project>> {
            return localVarFp.projectList(id, name, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this project.
         * @param {PatchedProject} [patchedProject]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectPartialUpdate(id: number, patchedProject?: PatchedProject, options?: any): AxiosPromise<Project> {
            return localVarFp.projectPartialUpdate(id, patchedProject, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectRetrieve(id: number, options?: any): AxiosPromise<Project> {
            return localVarFp.projectRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this project.
         * @param {Project} project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectUpdate(id: number, project: Project, options?: any): AxiosPromise<Project> {
            return localVarFp.projectUpdate(id, project, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export class ProjectApi extends BaseAPI {
    /**
     *
     * @param {Project} project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectCreate(project: Project, options?: any) {
        return ProjectApiFp(this.configuration).projectCreate(project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this project.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectDestroy(id: number, options?: any) {
        return ProjectApiFp(this.configuration).projectDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} [id]
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectList(id?: number, name?: string, options?: any) {
        return ProjectApiFp(this.configuration).projectList(id, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this project.
     * @param {PatchedProject} [patchedProject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectPartialUpdate(id: number, patchedProject?: PatchedProject, options?: any) {
        return ProjectApiFp(this.configuration).projectPartialUpdate(id, patchedProject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this project.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectRetrieve(id: number, options?: any) {
        return ProjectApiFp(this.configuration).projectRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this project.
     * @param {Project} project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public projectUpdate(id: number, project: Project, options?: any) {
        return ProjectApiFp(this.configuration).projectUpdate(id, project, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SplitConfigApi - axios parameter creator
 * @export
 */
export const SplitConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {SplitConfig} [splitConfig]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        splitConfigCreate: async (splitConfig?: SplitConfig, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/split_config/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(splitConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this split config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        splitConfigDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('splitConfigDestroy', 'id', id)
            const localVarPath = `/api/split_config/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} [id]
         * @param {string} [name]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        splitConfigList: async (id?: number, name?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/split_config/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this split config.
         * @param {PatchedSplitConfig} [patchedSplitConfig]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        splitConfigPartialUpdate: async (id: number, patchedSplitConfig?: PatchedSplitConfig, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('splitConfigPartialUpdate', 'id', id)
            const localVarPath = `/api/split_config/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSplitConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this split config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        splitConfigRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('splitConfigRetrieve', 'id', id)
            const localVarPath = `/api/split_config/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this split config.
         * @param {SplitConfig} [splitConfig]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        splitConfigUpdate: async (id: number, splitConfig?: SplitConfig, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('splitConfigUpdate', 'id', id)
            const localVarPath = `/api/split_config/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(splitConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SplitConfigApi - functional programming interface
 * @export
 */
export const SplitConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SplitConfigApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {SplitConfig} [splitConfig]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async splitConfigCreate(splitConfig?: SplitConfig, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SplitConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.splitConfigCreate(splitConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this split config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async splitConfigDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.splitConfigDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} [id]
         * @param {string} [name]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async splitConfigList(id?: number, name?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SplitConfig>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.splitConfigList(id, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this split config.
         * @param {PatchedSplitConfig} [patchedSplitConfig]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async splitConfigPartialUpdate(id: number, patchedSplitConfig?: PatchedSplitConfig, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SplitConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.splitConfigPartialUpdate(id, patchedSplitConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this split config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async splitConfigRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SplitConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.splitConfigRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this split config.
         * @param {SplitConfig} [splitConfig]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async splitConfigUpdate(id: number, splitConfig?: SplitConfig, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SplitConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.splitConfigUpdate(id, splitConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SplitConfigApi - factory interface
 * @export
 */
export const SplitConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SplitConfigApiFp(configuration)
    return {
        /**
         *
         * @param {SplitConfig} [splitConfig]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        splitConfigCreate(splitConfig?: SplitConfig, options?: any): AxiosPromise<SplitConfig> {
            return localVarFp.splitConfigCreate(splitConfig, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this split config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        splitConfigDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.splitConfigDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} [id]
         * @param {string} [name]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        splitConfigList(id?: number, name?: string, options?: any): AxiosPromise<Array<SplitConfig>> {
            return localVarFp.splitConfigList(id, name, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this split config.
         * @param {PatchedSplitConfig} [patchedSplitConfig]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        splitConfigPartialUpdate(id: number, patchedSplitConfig?: PatchedSplitConfig, options?: any): AxiosPromise<SplitConfig> {
            return localVarFp.splitConfigPartialUpdate(id, patchedSplitConfig, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this split config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        splitConfigRetrieve(id: number, options?: any): AxiosPromise<SplitConfig> {
            return localVarFp.splitConfigRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this split config.
         * @param {SplitConfig} [splitConfig]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        splitConfigUpdate(id: number, splitConfig?: SplitConfig, options?: any): AxiosPromise<SplitConfig> {
            return localVarFp.splitConfigUpdate(id, splitConfig, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SplitConfigApi - object-oriented interface
 * @export
 * @class SplitConfigApi
 * @extends {BaseAPI}
 */
export class SplitConfigApi extends BaseAPI {
    /**
     *
     * @param {SplitConfig} [splitConfig]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SplitConfigApi
     */
    public splitConfigCreate(splitConfig?: SplitConfig, options?: any) {
        return SplitConfigApiFp(this.configuration).splitConfigCreate(splitConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this split config.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SplitConfigApi
     */
    public splitConfigDestroy(id: number, options?: any) {
        return SplitConfigApiFp(this.configuration).splitConfigDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} [id]
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SplitConfigApi
     */
    public splitConfigList(id?: number, name?: string, options?: any) {
        return SplitConfigApiFp(this.configuration).splitConfigList(id, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this split config.
     * @param {PatchedSplitConfig} [patchedSplitConfig]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SplitConfigApi
     */
    public splitConfigPartialUpdate(id: number, patchedSplitConfig?: PatchedSplitConfig, options?: any) {
        return SplitConfigApiFp(this.configuration).splitConfigPartialUpdate(id, patchedSplitConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this split config.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SplitConfigApi
     */
    public splitConfigRetrieve(id: number, options?: any) {
        return SplitConfigApiFp(this.configuration).splitConfigRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this split config.
     * @param {SplitConfig} [splitConfig]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SplitConfigApi
     */
    public splitConfigUpdate(id: number, splitConfig?: SplitConfig, options?: any) {
        return SplitConfigApiFp(this.configuration).splitConfigUpdate(id, splitConfig, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TaskLogApi - axios parameter creator
 * @export
 */
export const TaskLogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} [id]
         * @param {number} [taskTaskandparameterjoblinkJob]
         * @param {number} [taskTaskandtrainedmodellinkModel]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskLogList: async (id?: number, taskTaskandparameterjoblinkJob?: number, taskTaskandtrainedmodellinkModel?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/task_log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (taskTaskandparameterjoblinkJob !== undefined) {
                localVarQueryParameter['task__taskandparameterjoblink__job'] = taskTaskandparameterjoblinkJob;
            }

            if (taskTaskandtrainedmodellinkModel !== undefined) {
                localVarQueryParameter['task__taskandtrainedmodellink__model'] = taskTaskandtrainedmodellinkModel;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this task log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskLogRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('taskLogRetrieve', 'id', id)
            const localVarPath = `/api/task_log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskLogApi - functional programming interface
 * @export
 */
export const TaskLogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaskLogApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {number} [id]
         * @param {number} [taskTaskandparameterjoblinkJob]
         * @param {number} [taskTaskandtrainedmodellinkModel]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskLogList(id?: number, taskTaskandparameterjoblinkJob?: number, taskTaskandtrainedmodellinkModel?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskLogList(id, taskTaskandparameterjoblinkJob, taskTaskandtrainedmodellinkModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this task log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskLogRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskLogRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TaskLogApi - factory interface
 * @export
 */
export const TaskLogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaskLogApiFp(configuration)
    return {
        /**
         *
         * @param {number} [id]
         * @param {number} [taskTaskandparameterjoblinkJob]
         * @param {number} [taskTaskandtrainedmodellinkModel]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskLogList(id?: number, taskTaskandparameterjoblinkJob?: number, taskTaskandtrainedmodellinkModel?: number, options?: any): AxiosPromise<Array<TaskLog>> {
            return localVarFp.taskLogList(id, taskTaskandparameterjoblinkJob, taskTaskandtrainedmodellinkModel, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this task log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskLogRetrieve(id: number, options?: any): AxiosPromise<TaskLog> {
            return localVarFp.taskLogRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaskLogApi - object-oriented interface
 * @export
 * @class TaskLogApi
 * @extends {BaseAPI}
 */
export class TaskLogApi extends BaseAPI {
    /**
     *
     * @param {number} [id]
     * @param {number} [taskTaskandparameterjoblinkJob]
     * @param {number} [taskTaskandtrainedmodellinkModel]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskLogApi
     */
    public taskLogList(id?: number, taskTaskandparameterjoblinkJob?: number, taskTaskandtrainedmodellinkModel?: number, options?: any) {
        return TaskLogApiFp(this.configuration).taskLogList(id, taskTaskandparameterjoblinkJob, taskTaskandtrainedmodellinkModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this task log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskLogApi
     */
    public taskLogRetrieve(id: number, options?: any) {
        return TaskLogApiFp(this.configuration).taskLogRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TokenApi - axios parameter creator
 * @export
 */
export const TokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPair} tokenObtainPair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenCreate: async (tokenObtainPair: TokenObtainPair, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenObtainPair' is not null or undefined
            assertParamExists('tokenCreate', 'tokenObtainPair', tokenObtainPair)
            const localVarPath = `/api/token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenObtainPair, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} tokenRefresh
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenRefreshCreate: async (tokenRefresh: TokenRefresh, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRefresh' is not null or undefined
            assertParamExists('tokenRefreshCreate', 'tokenRefresh', tokenRefresh)
            const localVarPath = `/api/token/refresh/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRefresh, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenApi - functional programming interface
 * @export
 */
export const TokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokenApiAxiosParamCreator(configuration)
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPair} tokenObtainPair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenCreate(tokenObtainPair: TokenObtainPair, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenObtainPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenCreate(tokenObtainPair, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} tokenRefresh
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenRefreshCreate(tokenRefresh: TokenRefresh, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenRefresh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenRefreshCreate(tokenRefresh, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TokenApi - factory interface
 * @export
 */
export const TokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokenApiFp(configuration)
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPair} tokenObtainPair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenCreate(tokenObtainPair: TokenObtainPair, options?: any): AxiosPromise<TokenObtainPair> {
            return localVarFp.tokenCreate(tokenObtainPair, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} tokenRefresh
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenRefreshCreate(tokenRefresh: TokenRefresh, options?: any): AxiosPromise<TokenRefresh> {
            return localVarFp.tokenRefreshCreate(tokenRefresh, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokenApi - object-oriented interface
 * @export
 * @class TokenApi
 * @extends {BaseAPI}
 */
export class TokenApi extends BaseAPI {
    /**
     * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
     * @param {TokenObtainPair} tokenObtainPair
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    public tokenCreate(tokenObtainPair: TokenObtainPair, options?: any) {
        return TokenApiFp(this.configuration).tokenCreate(tokenObtainPair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
     * @param {TokenRefresh} tokenRefresh
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    public tokenRefreshCreate(tokenRefresh: TokenRefresh, options?: any) {
        return TokenApiFp(this.configuration).tokenRefreshCreate(tokenRefresh, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TrainedModelApi - axios parameter creator
 * @export
 */
export const TrainedModelApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {TrainedModel} trainedModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainedModelCreate: async (trainedModel: TrainedModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'trainedModel' is not null or undefined
            assertParamExists('trainedModelCreate', 'trainedModel', trainedModel)
            const localVarPath = `/api/trained_model/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trainedModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this trained model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainedModelDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('trainedModelDestroy', 'id', id)
            const localVarPath = `/api/trained_model/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} [dataLoc]
         * @param {number} [dataLocProject]
         * @param {number} [id]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainedModelList: async (dataLoc?: number, dataLocProject?: number, id?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/trained_model/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dataLoc !== undefined) {
                localVarQueryParameter['data_loc'] = dataLoc;
            }

            if (dataLocProject !== undefined) {
                localVarQueryParameter['data_loc__project'] = dataLocProject;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this trained model.
         * @param {PatchedTrainedModel} [patchedTrainedModel]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainedModelPartialUpdate: async (id: number, patchedTrainedModel?: PatchedTrainedModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('trainedModelPartialUpdate', 'id', id)
            const localVarPath = `/api/trained_model/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedTrainedModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this trained model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainedModelRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('trainedModelRetrieve', 'id', id)
            const localVarPath = `/api/trained_model/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this trained model.
         * @param {TrainedModel} trainedModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainedModelUpdate: async (id: number, trainedModel: TrainedModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('trainedModelUpdate', 'id', id)
            // verify required parameter 'trainedModel' is not null or undefined
            assertParamExists('trainedModelUpdate', 'trainedModel', trainedModel)
            const localVarPath = `/api/trained_model/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trainedModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrainedModelApi - functional programming interface
 * @export
 */
export const TrainedModelApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrainedModelApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {TrainedModel} trainedModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainedModelCreate(trainedModel: TrainedModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrainedModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainedModelCreate(trainedModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this trained model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainedModelDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainedModelDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} [dataLoc]
         * @param {number} [dataLocProject]
         * @param {number} [id]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainedModelList(dataLoc?: number, dataLocProject?: number, id?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TrainedModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainedModelList(dataLoc, dataLocProject, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this trained model.
         * @param {PatchedTrainedModel} [patchedTrainedModel]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainedModelPartialUpdate(id: number, patchedTrainedModel?: PatchedTrainedModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrainedModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainedModelPartialUpdate(id, patchedTrainedModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this trained model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainedModelRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrainedModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainedModelRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this trained model.
         * @param {TrainedModel} trainedModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainedModelUpdate(id: number, trainedModel: TrainedModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrainedModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainedModelUpdate(id, trainedModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TrainedModelApi - factory interface
 * @export
 */
export const TrainedModelApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrainedModelApiFp(configuration)
    return {
        /**
         *
         * @param {TrainedModel} trainedModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainedModelCreate(trainedModel: TrainedModel, options?: any): AxiosPromise<TrainedModel> {
            return localVarFp.trainedModelCreate(trainedModel, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this trained model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainedModelDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.trainedModelDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} [dataLoc]
         * @param {number} [dataLocProject]
         * @param {number} [id]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainedModelList(dataLoc?: number, dataLocProject?: number, id?: number, options?: any): AxiosPromise<Array<TrainedModel>> {
            return localVarFp.trainedModelList(dataLoc, dataLocProject, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this trained model.
         * @param {PatchedTrainedModel} [patchedTrainedModel]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainedModelPartialUpdate(id: number, patchedTrainedModel?: PatchedTrainedModel, options?: any): AxiosPromise<TrainedModel> {
            return localVarFp.trainedModelPartialUpdate(id, patchedTrainedModel, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this trained model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainedModelRetrieve(id: number, options?: any): AxiosPromise<TrainedModel> {
            return localVarFp.trainedModelRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this trained model.
         * @param {TrainedModel} trainedModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainedModelUpdate(id: number, trainedModel: TrainedModel, options?: any): AxiosPromise<TrainedModel> {
            return localVarFp.trainedModelUpdate(id, trainedModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TrainedModelApi - object-oriented interface
 * @export
 * @class TrainedModelApi
 * @extends {BaseAPI}
 */
export class TrainedModelApi extends BaseAPI {
    /**
     *
     * @param {TrainedModel} trainedModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainedModelApi
     */
    public trainedModelCreate(trainedModel: TrainedModel, options?: any) {
        return TrainedModelApiFp(this.configuration).trainedModelCreate(trainedModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this trained model.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainedModelApi
     */
    public trainedModelDestroy(id: number, options?: any) {
        return TrainedModelApiFp(this.configuration).trainedModelDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} [dataLoc]
     * @param {number} [dataLocProject]
     * @param {number} [id]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainedModelApi
     */
    public trainedModelList(dataLoc?: number, dataLocProject?: number, id?: number, options?: any) {
        return TrainedModelApiFp(this.configuration).trainedModelList(dataLoc, dataLocProject, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this trained model.
     * @param {PatchedTrainedModel} [patchedTrainedModel]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainedModelApi
     */
    public trainedModelPartialUpdate(id: number, patchedTrainedModel?: PatchedTrainedModel, options?: any) {
        return TrainedModelApiFp(this.configuration).trainedModelPartialUpdate(id, patchedTrainedModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this trained model.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainedModelApi
     */
    public trainedModelRetrieve(id: number, options?: any) {
        return TrainedModelApiFp(this.configuration).trainedModelRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this trained model.
     * @param {TrainedModel} trainedModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainedModelApi
     */
    public trainedModelUpdate(id: number, trainedModel: TrainedModel, options?: any) {
        return TrainedModelApiFp(this.configuration).trainedModelUpdate(id, trainedModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TrainingDataApi - axios parameter creator
 * @export
 */
export const TrainingDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {TrainingData} trainingData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingDataCreate: async (trainingData: TrainingData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'trainingData' is not null or undefined
            assertParamExists('trainingDataCreate', 'trainingData', trainingData)
            const localVarPath = `/api/training_data/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trainingData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this training data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingDataDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('trainingDataDestroy', 'id', id)
            const localVarPath = `/api/training_data/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} [id]
         * @param {number} [project]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingDataList: async (id?: number, project?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/training_data/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (project !== undefined) {
                localVarQueryParameter['project'] = project;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this training data.
         * @param {PatchedTrainingData} [patchedTrainingData]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingDataPartialUpdate: async (id: number, patchedTrainingData?: PatchedTrainingData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('trainingDataPartialUpdate', 'id', id)
            const localVarPath = `/api/training_data/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedTrainingData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this training data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingDataRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('trainingDataRetrieve', 'id', id)
            const localVarPath = `/api/training_data/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id A unique integer value identifying this training data.
         * @param {TrainingData} trainingData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingDataUpdate: async (id: number, trainingData: TrainingData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('trainingDataUpdate', 'id', id)
            // verify required parameter 'trainingData' is not null or undefined
            assertParamExists('trainingDataUpdate', 'trainingData', trainingData)
            const localVarPath = `/api/training_data/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trainingData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrainingDataApi - functional programming interface
 * @export
 */
export const TrainingDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrainingDataApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {TrainingData} trainingData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingDataCreate(trainingData: TrainingData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrainingData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingDataCreate(trainingData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this training data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingDataDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingDataDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} [id]
         * @param {number} [project]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingDataList(id?: number, project?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TrainingData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingDataList(id, project, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this training data.
         * @param {PatchedTrainingData} [patchedTrainingData]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingDataPartialUpdate(id: number, patchedTrainingData?: PatchedTrainingData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrainingData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingDataPartialUpdate(id, patchedTrainingData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this training data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingDataRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrainingData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingDataRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id A unique integer value identifying this training data.
         * @param {TrainingData} trainingData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingDataUpdate(id: number, trainingData: TrainingData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrainingData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingDataUpdate(id, trainingData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TrainingDataApi - factory interface
 * @export
 */
export const TrainingDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrainingDataApiFp(configuration)
    return {
        /**
         *
         * @param {TrainingData} trainingData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingDataCreate(trainingData: TrainingData, options?: any): AxiosPromise<TrainingData> {
            return localVarFp.trainingDataCreate(trainingData, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this training data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingDataDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.trainingDataDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} [id]
         * @param {number} [project]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingDataList(id?: number, project?: number, options?: any): AxiosPromise<Array<TrainingData>> {
            return localVarFp.trainingDataList(id, project, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this training data.
         * @param {PatchedTrainingData} [patchedTrainingData]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingDataPartialUpdate(id: number, patchedTrainingData?: PatchedTrainingData, options?: any): AxiosPromise<TrainingData> {
            return localVarFp.trainingDataPartialUpdate(id, patchedTrainingData, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this training data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingDataRetrieve(id: number, options?: any): AxiosPromise<TrainingData> {
            return localVarFp.trainingDataRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this training data.
         * @param {TrainingData} trainingData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingDataUpdate(id: number, trainingData: TrainingData, options?: any): AxiosPromise<TrainingData> {
            return localVarFp.trainingDataUpdate(id, trainingData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TrainingDataApi - object-oriented interface
 * @export
 * @class TrainingDataApi
 * @extends {BaseAPI}
 */
export class TrainingDataApi extends BaseAPI {
    /**
     *
     * @param {TrainingData} trainingData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingDataApi
     */
    public trainingDataCreate(trainingData: TrainingData, options?: any) {
        return TrainingDataApiFp(this.configuration).trainingDataCreate(trainingData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this training data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingDataApi
     */
    public trainingDataDestroy(id: number, options?: any) {
        return TrainingDataApiFp(this.configuration).trainingDataDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} [id]
     * @param {number} [project]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingDataApi
     */
    public trainingDataList(id?: number, project?: number, options?: any) {
        return TrainingDataApiFp(this.configuration).trainingDataList(id, project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this training data.
     * @param {PatchedTrainingData} [patchedTrainingData]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingDataApi
     */
    public trainingDataPartialUpdate(id: number, patchedTrainingData?: PatchedTrainingData, options?: any) {
        return TrainingDataApiFp(this.configuration).trainingDataPartialUpdate(id, patchedTrainingData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this training data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingDataApi
     */
    public trainingDataRetrieve(id: number, options?: any) {
        return TrainingDataApiFp(this.configuration).trainingDataRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id A unique integer value identifying this training data.
     * @param {TrainingData} trainingData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingDataApi
     */
    public trainingDataUpdate(id: number, trainingData: TrainingData, options?: any) {
        return TrainingDataApiFp(this.configuration).trainingDataUpdate(id, trainingData, options).then((request) => request(this.axios, this.basePath));
    }
}
